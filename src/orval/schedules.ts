/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * スケジュール API
 * OpenAPI spec version: 1.0.0
 */

import { faker } from "@faker-js/faker";
import { delay, HttpResponse, http } from "msw";
import type { Key, SWRConfiguration } from "swr";
import useSwr from "swr";

import { getSchedulesMockFetcher } from "../../openapi/mock-fetch/schedules";
export interface Schedule {
  id: string;
  date: string;
  title: string;
  detail: string;
}

export interface ErrorResponse {
  message?: string;
}

export type GetSchedulesParams = {
  /**
   * ページ番号（1からスタート）
   * @minimum 1
   */
  page?: number;
  /**
   * ページあたりのスケジュール数
   * @minimum 1
   * @maximum 100
   */
  size?: number;
};

export type GetSchedules200 = {
  /** スケジュールの総数 */
  total?: number;
  /** 現在のページ番号 */
  page?: number;
  /** ページあたりのスケジュール数 */
  size?: number;
  schedules?: Schedule[];
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary スケジュール情報一覧を取得する
 */
export type getSchedulesResponse200 = {
  data: GetSchedules200;
  status: 200;
};

export type getSchedulesResponse500 = {
  data: ErrorResponse;
  status: 500;
};

export type getSchedulesResponseComposite =
  | getSchedulesResponse200
  | getSchedulesResponse500;

export type getSchedulesResponse = getSchedulesResponseComposite & {
  headers: Headers;
};

export const getGetSchedulesUrl = (params?: GetSchedulesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/schedules?${stringifiedParams}`
    : `/api/schedules`;
};

export const getSchedules = async (
  params?: GetSchedulesParams,
  options?: RequestInit,
): Promise<getSchedulesResponse> => {
  return getSchedulesMockFetcher<getSchedulesResponse>(
    getGetSchedulesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetSchedulesKey = (params?: GetSchedulesParams) =>
  [`/api/schedules`, ...(params ? [params] : [])] as const;

export type GetSchedulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSchedules>>
>;
export type GetSchedulesQueryError = ErrorResponse;

/**
 * @summary スケジュール情報一覧を取得する
 */
export const useGetSchedules = <TError = ErrorResponse>(
  params?: GetSchedulesParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getSchedules>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    request?: SecondParameter<typeof getSchedulesMockFetcher>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getGetSchedulesKey(params) : null));
  const swrFn = () => getSchedules(params, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary 対象のスケジュール情報を取得する
 */
export type getScheduleResponse200 = {
  data: Schedule;
  status: 200;
};

export type getScheduleResponse404 = {
  data: ErrorResponse;
  status: 404;
};

export type getScheduleResponse500 = {
  data: ErrorResponse;
  status: 500;
};

export type getScheduleResponseComposite =
  | getScheduleResponse200
  | getScheduleResponse404
  | getScheduleResponse500;

export type getScheduleResponse = getScheduleResponseComposite & {
  headers: Headers;
};

export const getGetScheduleUrl = (id: string) => {
  return `/api/schedules/${id}`;
};

export const getSchedule = async (
  id: string,
  options?: RequestInit,
): Promise<getScheduleResponse> => {
  const res = await fetch(getGetScheduleUrl(id), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getScheduleResponse["data"] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getScheduleResponse;
};

export const getGetScheduleKey = (id: string) =>
  [`/api/schedules/${id}`] as const;

export type GetScheduleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSchedule>>
>;
export type GetScheduleQueryError = Promise<ErrorResponse | ErrorResponse>;

/**
 * @summary 対象のスケジュール情報を取得する
 */
export const useGetSchedule = <TError = Promise<ErrorResponse | ErrorResponse>>(
  id: string,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getSchedule>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    fetch?: RequestInit;
  },
) => {
  const { swr: swrOptions, fetch: fetchOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!id;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetScheduleKey(id) : null));
  const swrFn = () => getSchedule(id, fetchOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

export const getGetSchedulesResponseMock = (
  overrideResponse: Partial<GetSchedules200> = {},
): GetSchedules200 => ({
  total: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined, multipleOf: undefined }),
    undefined,
  ]),
  page: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined, multipleOf: undefined }),
    undefined,
  ]),
  size: faker.helpers.arrayElement([
    faker.number.int({ min: undefined, max: undefined, multipleOf: undefined }),
    undefined,
  ]),
  schedules: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      date: faker.date.past().toISOString().split("T")[0],
      title: faker.string.alpha({ length: { min: 10, max: 20 } }),
      detail: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getGetScheduleResponseMock = (
  overrideResponse: Partial<Schedule> = {},
): Schedule => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  date: faker.date.past().toISOString().split("T")[0],
  title: faker.string.alpha({ length: { min: 10, max: 20 } }),
  detail: faker.string.alpha({ length: { min: 10, max: 20 } }),
  ...overrideResponse,
});

export const getGetSchedulesMockHandler = (
  overrideResponse?:
    | GetSchedules200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetSchedules200> | GetSchedules200),
) => {
  return http.get("*/schedules", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetSchedulesResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getGetScheduleMockHandler = (
  overrideResponse?:
    | Schedule
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<Schedule> | Schedule),
) => {
  return http.get("*/schedules/:id", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetScheduleResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};
export const getApiMock = () => [
  getGetSchedulesMockHandler(),
  getGetScheduleMockHandler(),
];
